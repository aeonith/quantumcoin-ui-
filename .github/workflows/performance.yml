name: perf
# MANDATORY GATE - REQUIRED FOR MAIN BRANCH
on:
  push:
    branches: ["main", "develop"]
  pull_request:

jobs:
  performance-gates:
    name: Performance Gates (P95 <100ms, 0% errors)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install k6
        run: |
          wget -q https://github.com/grafana/k6/releases/download/v0.47.0/k6-v0.47.0-linux-amd64.tar.gz
          tar -xzf k6-v0.47.0-linux-amd64.tar.gz
          sudo mv k6-v0.47.0-linux-amd64/k6 /usr/local/bin/
          
      - name: Start backend for testing
        run: |
          # Start backend API server for performance testing
          cd backend && cargo build --release
          cargo run --release &
          BACKEND_PID=$!
          echo $BACKEND_PID > backend.pid
          
          # Wait for backend to be ready (‚â§120s requirement)
          timeout 120 bash -c 'until curl -f http://localhost:8080/health; do sleep 2; done'
          
      - name: P95 latency test (<100ms budget)
        run: |
          k6 run --summary-trend-stats="p(95)" --out json=latency-results.json - << 'EOF'
          import http from 'k6/http';
          import { check } from 'k6';
          
          export let options = {
            vus: 10,
            duration: '60s',
          };
          
          export default function() {
            let response = http.get('http://localhost:8080/health');
            check(response, {
              'status is 200': (r) => r.status === 200,
              'response time < 100ms': (r) => r.timings.duration < 100,
            });
          }
          EOF
          
          # Verify P95 latency budget
          P95_LATENCY=$(cat latency-results.json | jq -r '.metrics.http_req_duration.values["p(95)"]')
          if (( $(echo "$P95_LATENCY > 100" | bc -l) )); then
            echo "‚ùå P95 latency ${P95_LATENCY}ms exceeds 100ms budget"
            exit 1
          fi
          echo "‚úÖ P95 latency: ${P95_LATENCY}ms (under 100ms budget)"
          
      - name: Zero error rate test (100 VUs, 0% tolerance)
        run: |
          k6 run --vus 100 --duration 5m --out json=stress-results.json - << 'EOF'
          import http from 'k6/http';
          import { check } from 'k6';
          
          export default function() {
            let response = http.get('http://localhost:8080/health');
            check(response, {
              'status is 200': (r) => r.status === 200,
            });
          }
          EOF
          
          # Verify zero error rate
          ERROR_RATE=$(cat stress-results.json | jq -r '.metrics.http_req_failed.values.rate')
          if (( $(echo "$ERROR_RATE > 0" | bc -l) )); then
            echo "‚ùå Error rate ${ERROR_RATE} exceeds 0% tolerance"
            exit 1
          fi
          echo "‚úÖ Zero error rate maintained under 100 VUs"
          
      - name: Stack boot time test (‚â§120s)
        run: |
          # Test that full stack boots within 120 seconds
          START_TIME=$(date +%s)
          
          # Start full stack
          docker-compose -f docker-compose.production.yml up -d
          
          # Wait for all services to be healthy
          timeout 120 bash -c '
            while ! curl -f http://localhost:8080/health >/dev/null 2>&1 || \
                  ! curl -f http://localhost:3000/ >/dev/null 2>&1; do
              sleep 2
            done
          '
          
          BOOT_TIME=$(($(date +%s) - START_TIME))
          
          if [ $BOOT_TIME -gt 120 ]; then
            echo "‚ùå Stack boot time ${BOOT_TIME}s exceeds 120s budget"
            exit 1
          fi
          
          echo "‚úÖ Stack boot time: ${BOOT_TIME}s (under 120s budget)"
          
      - name: Explorer backend smoke probe
        run: |
          # Ensure explorer endpoints return sane, non-empty values
          set -e
          
          echo "üîç Testing explorer backend endpoints..."
          
          # Test /status endpoint
          STATUS_RESPONSE=$(curl -s http://localhost:8080/status)
          if echo "$STATUS_RESPONSE" | grep -q '"status":"healthy"'; then
            echo "‚úÖ /status returns healthy"
          else
            echo "‚ùå /status failed or unhealthy: $STATUS_RESPONSE"
            exit 1
          fi
          
          # Test /blocks endpoint
          BLOCKS_RESPONSE=$(curl -s "http://localhost:8080/explorer/blocks?limit=1")
          if echo "$BLOCKS_RESPONSE" | grep -q '"blocks":\[' && ! echo "$BLOCKS_RESPONSE" | grep -q '"blocks":\[\]'; then
            echo "‚úÖ /blocks returns non-empty block data"
          else
            echo "‚ùå /blocks returns empty or invalid data: $BLOCKS_RESPONSE"
            exit 1
          fi
          
          # Test that we have actual blockchain height > 0
          HEIGHT=$(echo "$STATUS_RESPONSE" | jq -r '.height // 0')
          if [ "$HEIGHT" -gt 0 ]; then
            echo "‚úÖ Blockchain height: $HEIGHT (positive)"
          else
            echo "‚ùå Blockchain height is 0 - no blocks mined"
            exit 1
          fi
          
          echo "üéâ All explorer smoke tests passed!"
          
      - name: Cleanup
        if: always()
        run: |
          if [ -f backend.pid ]; then
            kill $(cat backend.pid) || true
          fi
          docker-compose -f docker-compose.production.yml down || true
