import type { NextApiRequest, NextApiResponse } from "next";

// REAL TRANSACTION PROCESSING - PRODUCTION CRYPTOCURRENCY SYSTEM
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== "POST") {
    return res.status(405).json({ 
      success: false, 
      error: "Method not allowed. Use POST." 
    });
  }

  try {
    const { sender, recipient, amount, fee = 0.001, password } = req.body || {};

    // REAL INPUT VALIDATION
    if (!sender || !recipient || !amount) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: sender, recipient, amount"
      });
    }

    // Validate QuantumCoin address format
    const qtcAddressRegex = /^QTC[A-Za-z0-9+/=]{35,50}$/;
    if (!qtcAddressRegex.test(sender) || !qtcAddressRegex.test(recipient)) {
      return res.status(400).json({
        success: false,
        error: "Invalid QuantumCoin address format"
      });
    }

    // Validate amount
    const numAmount = parseFloat(amount);
    const numFee = parseFloat(fee);
    if (isNaN(numAmount) || numAmount <= 0) {
      return res.status(400).json({
        success: false,
        error: "Invalid amount"
      });
    }

    if (isNaN(numFee) || numFee < 0) {
      return res.status(400).json({
        success: false,
        error: "Invalid fee"
      });
    }

    // Connect to REAL Rust backend
    const backendUrl = process.env.NEXT_PUBLIC_API_BASE || "http://localhost:8080";
    
    // Check sender balance first
    const balanceResponse = await fetch(`${backendUrl}/balance/${sender}`);
    const balanceData = await balanceResponse.json();
    
    if (!balanceResponse.ok) {
      return res.status(400).json({
        success: false,
        error: "Could not verify sender balance"
      });
    }

    const senderBalance = parseFloat(balanceData.balance || "0");
    const totalRequired = numAmount + numFee;

    if (senderBalance < totalRequired) {
      return res.status(400).json({
        success: false,
        error: `Insufficient balance. Required: ${totalRequired} QTC, Available: ${senderBalance} QTC`
      });
    }

    // Check RevStop™ status
    const revStopResponse = await fetch(`${backendUrl}/revstop/status/${sender}`);
    if (revStopResponse.ok) {
      const revStopData = await revStopResponse.json();
      if (revStopData.active && revStopData.permanent) {
        return res.status(403).json({
          success: false,
          error: "RevStop™ protection is permanently active on this wallet"
        });
      }
    }

    // REAL TRANSACTION CREATION
    const transactionData = {
      sender,
      recipient,
      amount: Math.floor(numAmount * 100000000), // Convert to satoshis
      fee: Math.floor(numFee * 100000000),
      timestamp: Date.now(),
      signature: "", // This would be generated by the backend with proper cryptography
      nonce: Math.floor(Math.random() * 1000000)
    };

    // Submit to REAL blockchain via Rust backend
    const transactionResponse = await fetch(`${backendUrl}/transaction`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Request-ID": `qtc_${Date.now()}_${Math.random().toString(36).slice(2)}`
      },
      body: JSON.stringify(transactionData)
    });

    if (!transactionResponse.ok) {
      const errorData = await transactionResponse.json().catch(() => ({}));
      return res.status(400).json({
        success: false,
        error: errorData.error || "Transaction failed"
      });
    }

    const transactionResult = await transactionResponse.json();

    // REAL RESPONSE WITH TRANSACTION HASH
    return res.status(200).json({
      success: true,
      transactionId: transactionResult.transaction_id || transactionResult.hash,
      sender,
      recipient,
      amount: numAmount,
      fee: numFee,
      status: "pending",
      timestamp: new Date().toISOString(),
      blockchainNetwork: process.env.QTC_NETWORK || "mainnet",
      confirmations: 0,
      estimatedConfirmationTime: "10 minutes"
    });

  } catch (error: any) {
    console.error("Transaction processing error:", error);
    return res.status(500).json({
      success: false,
      error: "Internal server error during transaction processing",
      timestamp: new Date().toISOString()
    });
  }
}
